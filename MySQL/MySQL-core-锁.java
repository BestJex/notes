----------------------------
锁							|
----------------------------
	# 并发事务访问相同记录的情况大致可以划分为3种
		读 - 读
			* 读不会有啥问题
		
		写 - 写
			* 在这种情况下会发生脏写的问题, 任何一种隔离级别都不允许这种问题的发生
			* 多个未提交事务相继对一条记录做改动时, 需要让它们排队执行
			* 这个排队的过程其实是通过锁来实现的
		
		读-写/写-读
			* 这种情况下可能发生脏读, 不可重复读, 幻读的问题
			* 解决这些问题有两种办法
				1, 读操作使用MVCC,写操作加锁(事务笔记已经说了),读写不冲突, 性能比较高
				2, 读写, 都加锁, 读写都是需要排队, 性能比较差
					* 一个事务在写记录的时候就给这条记录加锁, 那么其他事务就无法继续读取该记录了, 所以也就不会有脏读问题的产生了
					* 一个事务读取记录时就给该记录加锁, 那么另一个事务就无法修改该记录, 自然也不会发生不可重复读了
					* 当前事务在第一次读取记录时那些幻影记录并不存在, 所以读取的时候加锁就有点尴尬 --―― 因为你并不知道给谁加锁(但是可以解决)
		
	# 锁
		* 锁其实是一个内存中的结构, 在事务执行前本来是没有锁的, 也就是说一开始是没有锁结构和记录进行关联的
		* 当一个事务想对这条记录做改动时, 首先会看看内存中有没有与这条记录关联的锁结构, 当没有的时候就会在内存中生成一个锁结构与之关联
		* 一个锁里面有很多的信息
			trx信息
				* 代表这个锁结构是哪个事务生成的
			is_waiting
				* 代表当前事务是否在等待
				* is_waiting属性如果是false,我们把这个场景就称之为获取锁成功, 或者加锁成功, 然后就可以继续执行操作了
		
		* 一个锁的过程(update)
			1. A事务操作数据, 发现该记录还没锁的信息, 于是设置了一个关联:is_waiting=false, 获取到了锁, 开始执行

			2. B事务操作数据, 发现存在了锁信息, 于是也设置了一个关联:is_waiting=true,当前事务需要等待(获取锁失败, 或者加锁失败, 或者没有成功的获取到锁

			3. A线程事务提交之前, 会把生成的锁结构释放掉, 然后看看还有没有别的事务在等待获取锁,
				* 发现了事务B还在等待获取锁, 所以把事务B对应的锁结构的is_waiting属性设置为false
				* 然后把该事务对应的线程唤醒, 让它继续执行, 此时事务B就算获取到锁了

----------------------------
一致性读(Consistent Reads)  |
----------------------------
	# 事务利用MVCC进行的读取操作称之为一致性读, 或者一致性无锁读, 有的地方也称之为快照读
	# 所有普通的SELECT语句(plain SELECT)在READ COMMITTED, REPEATABLE READ隔离级别下都算是一致性读
	# 一致性读并不会对表中的任何记录做加锁操作, 其他事务可以自由的对表中的记录做改动

----------------------------
锁定读 (Locking Reads)	和写|
----------------------------
	# 共享锁, 英文名: Shared Locks, 简称S锁
		* 在事务要读取一条记录时, 需要先获取该记录的S锁
		* 共享锁语句
			SELECT ... LOCK IN SHARE MODE;

		* 当前事务执行了该语句, 那么它会为读取到的记录加S锁, 这样允许别的事务继续获取这些记录的S锁
		* 比方说别的事务也使用SELECT ... LOCK IN SHARE MODE语句来读取这些记录

		* 但是不能获取这些记录的X锁(比方说使用SELECT ... FOR UPDATE语句来读取这些记录, 或者直接修改这些记录)
		* 如果别的事务想要获取这些记录的X锁, 那么它们会阻塞, 直到当前事务提交之后将这些记录上的S锁释放掉
		
	# 独占锁, 英文名:Exclusive Locks, 简称X锁(也称为排他锁)
		* 在事务要改动一条记录时, 需要先获取该记录的X锁
		* 独占锁语句
			SELECT ... FOR UPDATE;
		
		* 如果当前事务执行了该语句, 那么它会为读取到的记录加X锁, 这样既不允许别的事务获取这些记录的S锁
		* 比方说别的事务使用SELECT ... LOCK IN SHARE MODE语句来读取这些记录, 更不允许获取这些记录的X锁
		* 如果别的事务想要获取这些记录的S锁或者X锁, 那么它们会阻塞, 直到当前事务提交之后将这些记录上的X锁释放掉

		
	# 锁的兼容
		兼容性	X		S
		X		不兼容	不兼容
		S		不兼容	兼容

		* 只有 s s 是兼容的
	
	# 写操作
		DELETE
			* DELETE操作的过程其实是先在B+树中定位到这条记录的位置, 然后获取一下这条记录的X锁
			* 然后再执行delete mark操作, 我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取X锁的锁定读

		UPDATE
			* 分为三种情况
				1. 如果'未修改该记录的键值', 并且'被更新的列占用的存储空间在修改前后未发生变化',
					* 则先在B+树中定位到这条记录的位置, 然后再获取一下记录的X锁, 最后在原记录的位置进行修改操作
					* 其实也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读
				
				2. 如果'未修改该记录的键值'并且'至少有一个被更新的列占用的存储空间在修改前后发生变化',
					* 则先在B+树中定位到这条记录的位置, 然后获取一下记录的X锁, 将该记录彻底删除掉(就是把记录彻底移入垃圾链表)
					* 最后再插入一条新记录, 这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读
					* 新插入的记录由INSERT操作提供的隐式锁进行保护
				
				3. '如果修改了该记录的键值'
					* 则相当于在原记录上做DELETE操作之后再来一次INSERT操作
					* 加锁操作就需要按照DELETE和INSERT的规则进行了

		INSERT
			* 新插入一条记录的操作一般并不加锁,但在一些特殊情况下INSERT操作也是会获取锁的
			* InnoDB的通过一种称之为隐式锁的东东来保护这条新插入的记录在本事务提交前不被别的事务访问

------------------------
多粒度锁				|
------------------------
	# 事务也可以在表级别进行加锁
		* 自然就被称之为表级锁或者表锁
		* 对一个表加锁影响整个表中的记录, 这个锁的粒度比较粗
	
	# 事务也可以在行级别进行加锁
		* 对一条记录加锁影响的也只是这条记录而已, 我们就说这个锁的粒度比较细
	
	# 给表加S锁
		别的事务可以继续获得该表的S锁
		别的事务可以继续获得该表中的某些记录的S锁
		别的事务不可以继续获得该表的X锁
		别的事务不可以继续获得该表中的某些记录的X锁

	# 给表加X锁
		别的事务不可以继续获得该表的S锁
		别的事务不可以继续获得该表中的某些记录的S锁
		别的事务不可以继续获得该表的X锁
		别的事务不可以继续获得该表中的某些记录的X锁
	

	# 意向锁(Intention Locks)
		* 我们在对表上锁时,需要确定表中的行是否被上锁, 如果使用遍历, 效率很低
		* 于是设计了意向锁
	
		* 意向共享锁,英文名：Intention Shared Lock, 简称IS锁
			* 当事务准备在某条记录上加S锁时, 需要先在表级别加一个IS锁

		* 意向独占锁,英文名: Intention Exclusive Lock, 简称IX锁
			* 当事务准备在某条记录上加X锁时, 需要先在表级别加一个IX锁
		
		* IS, IX锁是表级锁, 它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁, 以避免用遍历的方式来查看表中有没有上锁的记录
		* 也就是说其实IS锁和IX锁是兼容的, IX锁和IX锁是兼容的
	
	# 兼容性
		兼容性	X		IX		S		IS
		X		不兼容	不兼容	不兼容	不兼容
		IX		不兼容	兼容	不兼容	兼容
		S		不兼容	不兼容	兼容	兼容
		IS		不兼容	兼容	兼容	兼容

------------------------
行锁和表锁				|
------------------------
	

-------------------------------------------------
Read Committed, 是否能彻底解决幻读的问题		 |
-------------------------------------------------
	# MYSQL 的 Read Committed, 其实是可以解决幻读的问题
		+---------------------------+-------------------------------------------+
		|  SESSION1					|  SESSION2									|
		+-----------------------------------------------------------------------+
		|start transaction;			|	start transaction;						|
		+-----------------------------------------------------------------------+
		|select * from `user`;		|											|
		+-----------------------------------------------------------------------+
		|							|	insert into `user` values(2, 0, 0);		|
		+-----------------------------------------------------------------------+
		|							|	commit;									|
		+-----------------------------------------------------------------------+
		|select * from `user`;		|											|
		+-----------------------------------------------------------------------+
		|commit;					|											|
		+-----------------------------------------------------------------------+
		
		* SESSION1 先执行 select 发现读取不到数据
		* SESSION2 执行 insert 插入了记录
		* SESSION1 再次 select语句, 不能检索到session2的新插入的记录
		* 如果SESSION2 执行删除提交, 那么SESSION1 未提交之前还是可以读取到这条已经被删除的记录


	# MYSQL 的 Read Committed, 不一定可以彻底解决幻读的问题
		* 数据信息
			+----+---------+---------+
			| id | balance | version |
			+----+---------+---------+
			|  1 |       0 |       1 |
			|  2 |       0 |       1 |
			+----+---------+---------+
		
		* 检索
			+-------------------------------------------------------+-------------------------------------------+
			|SESSION1												|SESSION2									|
			+-------------------------------------------------------+-------------------------------------------+
			|start transaction;										|start transaction;							|
			+-------------------------------------------------------+-------------------------------------------+
			|select * from `user` where `version` = 2;				|											|
			+-------------------------------------------------------+-------------------------------------------+
			|														|insert into `user` values(3, 0, 2);		|
			+-------------------------------------------------------+-------------------------------------------+
			|														|commit;									|
			+-------------------------------------------------------+-------------------------------------------+
			|select * from `user` where `version` = 2;				|											|
			+-------------------------------------------------------+-------------------------------------------+
			|update `user` set `balance` = 1 where `version` = 2;	|											|
			+-------------------------------------------------------+-------------------------------------------+
			|select * from `user` where `version` = 2;				|											|
			+-------------------------------------------------------+-------------------------------------------+
			|commit;												|											|
			+-------------------------------------------------------+-------------------------------------------+
			
			* SESSION1 第一次检索, DB记录不存在
			* SESSION1 第二次检索, 检索不到SESSION2新插入的记录, 防止了幻读
				Empty set (0.00 sec)

			* 但是SESSION1 尝试去对 SESSION2 新插入的记录执行 UPDATE, 可以修改成功
			* 修改成功后, 再次执行 SELECT, 可以检索出SESSION2新插入的记录
				+----+---------+---------+
				| id | balance | version |
				+----+---------+---------+
				|  3 |       1 |       2 |
				+----+---------+---------+
			
			* 原因
				- 在REPEATABLE READ隔离级别下, T1第一次执行普通的SELECT语句时生成了一个ReadView, 之后T2向hero表中新插入了一条记录便提交了
				- ReadView并不能阻止T1执行UPDATE或者DELETE语句来对改动这个新插入的记录, 因为T2已经提交, 所以改动该记录并不会造成阻塞
				- 但是这样一来这条新记录的 trx_id 隐藏列就变成了T1的事务id, 之后T1中再使用普通的SELECT语句去查询这条记录时就可以看到这条记录了
				- 也就把这条记录返回给客户端了, 因为这个特殊现象的存在, 也可以认为InnoDB中的MVCC并不能完完全全的禁止幻读


			
			
			
					


		
		
