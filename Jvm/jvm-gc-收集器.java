------------------------
Gc收集器				|
------------------------
	# 收集算法是内存回收的方法论, 收集器则是实现了
	# jvm规范对收集器怎么去实现, 没有任何规定, 所以不同厂家, 不同版本的可能不一样

	# GC收集器目前主要的有
		Serial
		ParNew
		Parallel Scavenge
	
		Garbage First(G1)
		Concurrent Mark Sweep(CMS)
		Parallel Old
		Serial Old(MSC)

		* 不同的收集器可以共存, 组合使用
		* 它们之间没有绝对的最完美的收集器,(如果有, 也不用实现那么多出来)
	
	
	# 可能涉及到的名词解释
		* 并行
			* 多个GC收集器线程在同时的工作, 但是应用线程处于终止状态

		* 并发
			* 应用线程和GC收集线程同时(因为CPU核心数的问题,可能会交替执行)执行

------------------------
Serial					|
------------------------
	# 最基本的, 历史最悠久的收集器, 在JDK1.3.1之前是虚拟机新生代的唯一选择
	# 这个收集器是一个单线程的收集器
	# 它在执行GC的时候, 会暂停所有的工作线程, 直到它收集结束

	# 它在Client模式下的虚拟机来说, 是一个很好的选择
		* Client模式(桌面环境), 一般分配给jvm管理的内存不是很大
		* GC导致的停顿时间, 完全可以控制在几十毫秒 - 100毫秒以内, 这是可以接收的
		* 单线程, 免去了多线程的切换, 可以专注的进行收集工作, 效率更高
	
------------------------
ParNew					|
------------------------
	# 它其实就是 Serial 的多线程版本
	# 还可以通过一系列的JVM参数对它进行控制
		-XX:SurvivorRatio
		-XX:PretenureSizeThreshold
		-XX:HandlePromotionFailure
	
	# 他的工作流程
		1. (第一阶段标记)暂停业务线程, 多线程收集
		2. 唤醒业务线程
		3. (第二阶段标记)暂停业务线程, 单线程执行GC
	

	# 它相对于 Serial 并没太多的创新之处, 甚至连部分代码都是共用的, 但它却是很多在运行Server模式的JVM的'新生代'首选收集器
		* 因为一个与性能无关的原因
		* 除了 Serial 以外, 只有它能与Concurrent Mark Sweep(CMS)收集器配合工作
	
	# 在单核的CPU环境中, 它的效果不一定比 Serial 好
		* 甚至由于多线程交互的开销, 可能不如 Serial
		* 这个收集器, 在通过超线程技术实现的两个CPU核心环境中, 都不能100%的 保证超越 Serial 

	# 随着CPU核心数量的增加, 它对于GC时系统资源的有效利用还是很有好处的
		* 默认开启的收集线程数量与CPU的核心数量相同
		* 在核心数量非常多的情况下, 可以通过参数来限制垃圾收集的线程的数量
			-XX:ParallelGCThreads=10


	# 指定使用ParNew收集器
		-XX:+UseConMarkSweepGC
			* 使用Concurrent Mark Sweep(CMS)作为老年代收集器
			* 如果使用该参数, 默认就会使用: ParNew 作为新生代的收集器

		-XX:+UseParNewGC
			* 强制系统使用 ParNew 作为新生代的收集器
		
