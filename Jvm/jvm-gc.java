-----------------------
Garbage	Collection     |
-----------------------
	# GC考虑的三个东西
		* 哪些内存需要回收?
		* 什么时候回收?
		* 如何回收?
	
-----------------------
引用计数算法		   |
-----------------------
	# 给对象添加一个引用计数器
		* 添加引用, 计数器 +1
		* 引用时效, 计数器 -1

		* 计数器 == 0, 则对象不可用
	
	# Java主流的JVM没有选用这个算法来管理内存
		* 主要是这东西很难解决'循环引用'的问题
			class A {
				public Object instance;
			}
			class B{
				public Object instance;
			}
			public class Main {
				public static void main(String[] args) {
					A a = new A();
					B b = new B();
					a.instance = b;
					b.instance = a;
					a = null;
					b = null;
					System.gc();
				}
			}
	
-----------------------
可达性分析算法		   |
-----------------------
	# 主流的语言, 都是采用这个GC算法
		- Java
		- C#(辣鸡语言)
		- Lisp
	
	# 基本的思想
		* 通过一系列的 'GC Roots' 作为起始点
		* 从起始点往下搜索的路径, 成为引用链(树状)
		* 当一个对象到 'GC Roots' 没有任何引用链的时候, 就可以证明该对象不可用的
	
	# 可以作为 'GC Roots' 的对象
		* 虚拟机栈用引用的对象
		* 方法区中类静态属性引用的对象
		* 本地方法栈中JNI(Native方法)引用的对象
	

-----------------------
引用				   |
-----------------------
	# 强引用(Strong Refrence)
		* 普遍存在的: Object instance = new Object();
		* 只要关联还在, 不会回收内存

	# 软引用(Soft Reference)
		* 描述一些有用,但非必须的对象
		* 在系统即将发生内存溢出之前, 会把这些对象列进回收范围内, 进行二次回收
		* 如果内存还是不足, 则抛出内存溢出异常
		* JDK 提供的实现类:SoftReference<T>

	# 弱引用(Weak Reference)
		* 描述非必须的对象
		* 它只能存在于下一次GC之前, 下一次GC, 不论内存是否足够, 都会回收掉那些仅被弱引用关联的对象
		* JDK 提供的实现类:WeakReference<T>

	# 虚引用(Phantom Reference)
		* 虚引用关系的存在不会影响它的生存时间, 无法根据虚引用访问到对象
		* 设置虚引用的唯一目的:在这个对象被GC回收时, 收到系统通知
		* JDK提供的实现类:PhantomReference<T>



----------------------------
对象的回收至少会经过两次标记|
----------------------------
	# 第一次标记
		* 经过可达性分析后, 发现对象没有与 Gc Roots 关联
		* 如果覆写了 finalize 方法, 并且还没被调用过
			- 把对象放置到一个名为:F-Queue 的队列中, 稍后会通过一个虚拟机自动创建的一个低优先级线程(Finalizer)去执行finalize方法
			- 虚拟机只是会触发这个方法, 但是不会阻塞到这个方法结束, 因为如果这个方法执行缓慢, 或者发生了死循环, 可能导致: F-Queue 队列中的其他对象永远处于等待状态, 甚至导致GC系统崩溃

	# 第二次标记
		* 如果在第一次标记的时候,如果对象通过 finalize() 发生了自救的行为(把自己赋值到其他的对象或者其他的行为, 反正可以引用到GC Roots), 那么第二次标记就会把对象从即将回收集合移除
	
	# finalize()  不建议使用, 快忘记
		* 这并不是C/C++的析构函数, 而是为了骗搞C/C++的开发者上Java贼船而鼓捣的东西
		* 运行代价高昂, 不确定性大, 无法保证各个对象的调用顺序
	
			
----------------------------
关于方法区的回收			|
----------------------------
	# 蛮多人认为方法区(HopSpot中的 Metaspeace(永久代))是没有GC的
		* jvm规范也定义了不需要在方法区中实现gc
		* 而且在方法区中实现gc, 性价比比较低(耗费了性能, 但是回收不到多少空间)
		* 比起搜刮方法区, 不如果搜刮新生代
	
	# 永久代的垃圾回收, 分为两个部分: 废弃的常量, 无用的类
	
	# 废弃的常量
		* 这个跟回收Java对象非常相似, 不存在引用则回收
	
	# 无用的类, 这个判断比较苛刻, 必须满足以下的所有条件
		* 该类的所有实例都已经被回收, 系统中不存在该类的实例
		* 加载该类的 ClassLoader 已经被回收
		* 该类的 Class 对象, 没有在任何地方被引用, 也就说无法在任何地方通过反射获取到该类的方法

		* 满足条件, 可以被进行回收, 而回收不是必须的, 可以通过 jvm 参数控制
			* 关闭Class的回收
				-Xnoclassgc
			
			* 查看类的加载/卸载信息
				-verbose:class -XX:+TraceClassLoading -XX:+TraceClassUnloading
